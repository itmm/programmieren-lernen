# Programmieren Lernen
* author: Timm Knape

## Programmieren ist Zauberei

### Im Keller

Das Gewölbe ist düster.
Grauer Rauch steigt langsam wabernd aus großen, bronzenen Schalen
auf.
Von verborgenen LED-Strahlern wird er lila angestrahlt und
mystifiziert die gesamte Szene.
Leise klirren indische Klang-Schalen kreuz und quer, ohne sich
verorten zu lassen.

Ein Mann in langem Mantel steht auf einmal mitten im Raum.
Niemand hat ihn kommen sehen.
Auf dem Mantel sind mit goldenen Fäden Symbole aus unterschiedlichen
Schrift-Systemen aufgestickt.
Wenn etwas nach einem bekannten lateinischen Buchstaben aussieht,
dann ist es sicherlich ein griechisches, kyrillisches oder ganz
anderes Symbol.

Der Mann breitet langsam die Arme aus.
Gleichzeitig verändert sich der Raum.
Die Temperatur sinkt.
Das Licht nimmt sich zurück.
Nur eine gelbe Lichtsäule bildet sich um den Magier.

Wo vorher noch unbestimmte Leere war, leuchtet nun ein Pentagramm
auf dem groben Felsboden.
In dessen Mitte steht der Zauberkundige.

Er murmelt kaum verständlich eine Beschwörungsformel in einer
fremden Sprache.
Teile erinnern an Latein.
Dabei bewegen sich seine Finger als wären sie zu einem eigenen,
unabhängigen Leben erwacht und erkunden wie frisch geschlüpfte
Küken die große Welt.

Ruckartig senkt er die Arme.
Ein Donnerschlag dröhnt durch die Halle.
Ein kleiner Bistro-Tisch steht wie aus dem Nichts vor ihm.
Auf diesem liegen dampfende Papp-Kartons.

„Bitte nehmen Sie sich, Ihre Pizza. Ich hoffe, der Tag hat Ihnen
gefallen.“

Mit einer knappen Verbeugung verabschiedet sich der Künstler und
verläßt das Gewölbe, in dem eine Management-Schulung zu ihrem
Abschluß gekommen ist.

### Quer-Bezug

Ja und?
Was hat das alles mit Programmieren zu tun?
Eine Menge!

Für den Außenstehenden wirkt Programmieren wie Magie.
Programmierkundige können seelenlose Maschinen zum Leben erwecken.
Durch die zunehmende Vernetzung werden die Programme scheinbar
allwissend.

Wie ein böser Dämon müssen sie von ihrem Meister gebändigt und in
Zaum gehalten werden.

Aber gleichzeitig ist das Programmieren für erfahrene Programmierer
eben keine Hexerei.
So wie auch ein Zauberkünstler keine echte Magie braucht, um seine
Kunststücke vorzuführen.

Dieses Buch ist der erste Schritt einer Anleitung zum Programmieren.

Alles was du brauchst ist ein Gerät mit Internet-Anschluß, auf dem
ein Web-Browser läuft.
Zum Beispiel ein Tablet oder Smart-Phone.
Oder ein Laptop.
Oder ein Desktop-Computer.
Das sind diese Kisten mit abgesetzten Bildschirm und Tastatur.

Damit können wir ein klein wenig programmieren lernen.
Es ist gar nicht so schwer.
Die Programme sind unsere Zaubersprüche.
Der Web-Browser ist der Raum, in dem wir wirken.
Und mit etwas Geduld entstehen komplexe Gebilde, die scheinbar
viel mächtiger sind, als die paar Zeilen Programm-Text vermuten
lassen.

Lass uns das Spiel beginnen!

## Um was geht es?

Es ist total wichtig, dass wir ganz klar Wissen, um was es überhaupt
geht.
Wenn wir kein gemeinsames Verständnis der verwendeten Begriffe haben,
dann ist es höchstens Glück, wenn Wissen und Erkenntnis transportiert
werden.
Das kann funktionieren. Muss es aber nicht.

### Definitionen

Zuerst geht es um unsere eigene Rolle.
Der *Programmierer* oder die *Programmiererin* erstellen
Programme.
Gute Programmierer zeichnen sich dadurch aus, dass sie recht schnell
Programme erstellen können, die relativ wenig Fehler haben und
selber schnell laufen.
Aber das sind vorerst nur Details.
Wichtig ist: Wir müssen Programme schreiben.

*Programme* selbst sind Anweisungen, die so klar und haarklein
umrissen sind, dass selbst eine Maschine sie ausführen kann.
Es gibt unterschiedliche *Programmiersprachen*, in denen
Programme formuliert werden können.

Ein Beispiel ist JavaScript, das heute in fast jedem Web-Browser
verwendet werden kann.
Aber JavaScript hat so seine Tücken.
Es wird leichter sein, mit einer einfacheren Sprache anzufangen.

Als drittes Element gibt es noch die *Maschine*, welche ein
Programm ausführt.
Das kann ein Computer sein.
Muss es aber nicht.

Das folgenden Beispiel zeigt, wie man schon um 1900 ein Programm
ganz ohne Elektronik schreiben und ausführen konnte.

### Beispiel: Taylorismus

Die Fabriken sind ein schönes Beispiel für das nicht-elektronische
Ausführen eines Programms.
Man spricht auch gerne vom Abarbeiten eines Programms:
Es gibt eine Liste von Schritten, die nacheinander ausgeführt werden
müssen.

Zur Ehre des großen Pionier-Geists von Henry Ford und der Besinnung
als Teil einer Auto-Nation, habe ich ein etwas vereinfachtes
Programm geschrieben, wie ein Auto in einer Fabrik gebaut wird:

1. Nehme vier Reifen $r_1,\ldots,r_4$.
2. Nehme ein Lenkrad $rr$.
3. Baue in wenigen, nicht näher beschriebenen Schritten aus
   $r_1,\ldots,r_4,rr$ mit zusätzlichem Material einen roten VW Polo.

Natürlich war die eigentliche Liste in Wolfsburg etwas länger.
Aber die würde den Rahmen sprengen und rechtliche Streitigkeiten
heraufbeschwören.

Bleiben wir bei den drei Schritten.

Die Programmierer in der Fabrik sind die Ingenieure und
Wissenschaftler, die alle Schritte zusammentragen, die notwendig
sind, um ein Auto zu bauen.

Je genauer die Schritte beschrieben sind, desto einheitlicher sind
die resultierenden Autos.
Und desto weniger muss der Fließband-Arbeiter in der Fabrik vom
Auto-Bauen verstehen.

In unserem vereinfachten Programm sind die ersten beiden Schritte
mit einigen Minuten anlernen ausführbar:
Da hinten liegen Reifen, dort im Regal sind die Lenkräder.
Nun sieh zu!

Für den dritten Schritt braucht es etwas mehr Expertise.
Die ich leider selber nicht besitze.
Daher muss ich beim Auto-Bauen notgedrungen eine sehr kompetente
Maschine zum Ausführen meines Programms voraussetzen.

In diesem Beispiel ist die Fabrik-Halle mit ihren Arbeitern,
Fließ-Bändern und Lackier-Robotern die Maschine, die das Programm
„ich baue einen Polo“ ausführen kann.

Dazu benötigt die Fabrik zusätzliches Material als Eingabe.
Irgendwo müssen auch die Räder und Lenkräder herkommen.
Auch Betriebsmittel wie Strom und Geld sind notwendig.

Und sie produziert ein Auto als Ausgabe.
Diese Begriffe werden wir später noch präzisieren müssen.

### Etwas realistischer

Ein Programm zum Auto-Bauen ist heute gar nicht mehr so abwegig.

Heute können Autos vielfältig konfiguriert werden.
Das erleichtert zum einen den Händlern, sich um das Rückgaberecht
zu drücken.
Aber auch die Kunden genießen, dass ihr Auto ganz individuell zu
ihnen passt und nicht in einem Einheits-Schwarz wie alle anderen
Autos herumfährt. Obwohl schwarz immer noch eine sehr verbreitete
Farbe ist.

Aber die Konfiguration eines Autos ist im Prinzip auch ein Programm.
Es bekommt nicht jeder Arbeiter in der Fabrik eine Kopie meines
Bestell-Zettels, aber er bekommt eine Liste mit Schritten, die er
ausführen muss, um genau mein Auto zu bauen.

Diese Listen werden nicht händisch erstellt.
Vielmehr gibt es ein Programm, das aus der Konfiguration (die ja wie
gesagt auch ein Programm ist) ein anderes Programm macht.
Solche Programme nennt man *Compiler*.
Und mit ihnen kann man jede Menge Schabernack anstellen.

### Andere Namen

Zusammen mit dem Programm wird oft der Begriff *Algorithmus*
verwendet.
Ein Algorithmus beschreibt, wie ein Programm funktioniert.
Er ist meistens nicht in einer Programmier-Sprache geschrieben,
sondern abstrakt.
Ein Computer kann einen Algorithmus nicht direkt ausführen.
Ein Mensch kann es jedoch.
Also ist ein Algorithmus durchaus ein Programm für die Maschine
Programmierer.
Meistens übernimmt es dann der Programmierer den Algorithmus in
ein Programm einer anderen Programmiersprache zu übersetzen, so dass
ein Computer ihn ausführen kann.

Aber für uns macht das erst einmal keinen Unterschied.
Ein Algorithmus ist ein Programm für eine bestimmte Maschine (uns!).
Ein Algorithmus hat noch zusätzliche Einschränkungen, die an dieser
Stelle noch nicht behandelt werden sollen.

Gerne wird anstatt des Begriffs Programm auch der *Prozess*
verwendet.
Besonders wenn die ausführende Maschine Menschen enthält.
Aber auch handelt es sich nur um ein Programm für eine bestimmte
Maschine.
Ähnlich wie beim Algorithmus sind die Unterschiede hauptsächlich
ästhetischer Natur.

*Koch-Rezepte* werden auch immer wieder gerne als ein Beispiel
für Programme herangezogen.
Dem kann ich nur anschließen.
Unser Begriff des Programms ist allgemein genug, um Rezepte mit zu
umfassen.
Am Beispiel des Rezeptes können auch wieder schön die einzelnen
Komponenten unterschieden werden.
Ein Rezept macht noch keinen Eierpfannkuchen.
Dazu benötigt man noch eine ausführende Maschine (den Koch) und
die notwendigen Zutaten (Eier, Mehl) und Betriebsmittel
(Herd, Pfanne).
Nur so kann die erwünschte Ausgabe produziert und danach verzehrt
werden.

## Zeichnen lassen

Genug der Vorrede.
Auf zum ersten richtigen Programm!
Unter `https://itmm.github.io/yoshi/` gibt es eine Web-Seite
mit zwei Feldern.
In das eine Feld kann das Programm eingegeben werden.
Das Programm besteht aus Mal-Anweisungen.

Die Anweisungen richten sich an die Schildkröte Yoshi aus der Mario-Welt,
die in der Mitte des zweiten Feldes sitzt und nach oben sieht.
Ihre Aufgabe ist es, Fahrbahnmarkierungen auf eine neue Straße zu
zeichnen.
Aber ihr muss ganz genau gesagt werden, was sie zeichnen muss.
Aus lizenz-rechtlichen Gründen wird Yoshi selber nicht gezeichnet.

Nach Klick auf den „Auftrag ausführen“-Knopf werden die Anweisungen
ausgeführt.
Das Ergebnis erscheint im anderen Feld:

!(yoshi-3.pdf)

Sehen wir uns das Programm genauer an:

```lisp
(markiere 20)
(drehe 120)
(markiere 20)
(drehe 120)
(markiere 20)
(drehe 120)
```

Jede Zeile ist eine eigene Anweisung.
Jede Anweisung beginnt mit `(` und endet mit `)`.

Das erste Wort in der Anweisung ist der *Name* der Anweisung.
Er sagt Yoshi, was für eine Aktion er ausführen soll.
Im ersten Programm gibt es nur die Namen `markiere` und `drehe`.

Die erste Anweisung `(markiere 20)` fordert die Schildkröte auf,
zwanzig Schritte in die aktuelle Richtung zu laufen.
Dabei hinterläßt sie eine Linie.

Die nächste Anweisung `(drehe 120)` dreht die Schildkröte um
`120` Grad (eine Drittel-Drehung) im Uhrzeigersinn.
Sie blickt nun nach rechts/unten.
Die nächste Linie fährt also in einem spitzen Winkel in diese Richtung.

Nach insgesamt drei Markierungen und Drehungen steht Yoshi wieder
auf seinem Startpunkt und blickt wieder nach oben.
Zusätzlich hat sie aber ein Dreieck gezeichnet.

### Ein Quadrat zeichnen

Wie sieht nun ein Programm aus, dass Yoshi dazu bringt ein Quadrat zu
zeichnen?

Anstatt drei Linien müssen vier Linien gezogen werden.
Und anstatt von Drittel-Drehungen müssen Viertel-Drehungen ausgeführt
werden.

Das Programm kann wie folgt aussehen:


```lisp
(markiere 20)
(drehe 90)
(markiere 20)
(drehe 90)
(markiere 20)
(drehe 90)
(markiere 20)
(drehe 90)
```

Es liefert das folgende Ergebnis:

!(yoshi-4.pdf)

### Erste Erkenntnisse

Jetzt haben wir schon zwei Programme geschrieben:
Mit dem ersten malt Yoshi ein Dreieck.
Mit dem zweiten malt die Schildkröte ein Quadrat.
Schon beim Quadrat fällt auf, wie mühevoll es ist, Yoshi geometrische
Formen zu erklären.
Zwar kann man mit etwas probieren Programme schreiben, die nun auch
Vierecke, Fünfecke und so weiter schreiben.
Aber für die Errechnung der Winkel wird irgendwann ein Taschenrechner
notwendig.
Und komfortabel ist die Eingabe auch nicht.

Ich gebe zu, ich habe beim Ausprobieren nur die ersten zwei Zeilen
angepasst, diese kopiert und dann weitere Male eingefügt.
Die restlichen Zeilen des alten Programms habe ich gelöscht.
Wenn Programmiersprachen keine Wiederholungen unterstützen, ist das
leider das Einzige, was bleibt.

Das hat gravierende Nachteile:
Wenn man später etwas verändern will, müssen viele Zeilen angepasst
werden.
Wenn man ein paar vergißt, funktioniert das Programm vielleicht nicht
mehr richtig.
Bereits bei der Umschreibung vom Dreiecks-Programm zum Quadrat-Programm
kann man dies beobachten.

Man sollte meinen, dass es in den letzten Jahren genug Fortschritte
gegeben hat, um uns diese Mühsal zu ersparen.
Leider weit gefehlt: das Kopieren und wiederholte Einfügen ist zum
Beispiel bei Tabellenkalkulationen immer noch der Weg der Wahl.

Zum Glück ist Yoshi cleverer.

### Wiederholen

Das Programm zum Zeichnen eines Quadrats kann man auch so aufschreiben:

```lisp
(wiederhole 4
	(markiere 20)
	(drehe 90)
)
```

Das ist viel weniger zum Tippen, aber bringt das gleiche Resultat.
Programmierer sind faul: warum arbeiten, wenn der Rechner auch die
Arbeit für einen erledigen kann. Oftmals ist der Computer dabei
gründlicher und macht weniger Fehler.

Aber erst einmal soll geklärt werden, was das Programm überhaupt macht,
bzw. wieso es funktioniert.

Der erste Befehl heißt `wiederhole` und hat drei Argumente.
Ja, genau: $3$.
Das erste Argument ist eine Zahl.
Die beiden weiteren Argumente sind wieder Befehle!

Der `wiederhole` Befehl nimmt das erste Argument und führt die weiteren
Argumente so oft aus, wie in dem ersten Argument angegeben wurde.

Oder noch genauer: solange das erste Argument größer als $0$ ist,
werden die weiteren Befehle ausgeführt und danach das erste Argument um
$1$ reduziert.
Anstatt $4$ könnte man im Programm auch $3.2$ schreiben.
Wichtig ist, dass Dezimalzahlen wie im Englischen mit einem
Dezimal-Punkt anstatt des deutschen Dezimal-Kommas geschrieben werden
müssen.
Aber grundsätzlich kann jede Zahl als erstes Argument von `wiederhole`
verwendet werden.

Bleibt nur das lästige Problem mit der Winkel-Berechnung.

### Winkel berechnen

Das können wir zum Glück auch dem Rechner überlassen.

Yoshi soll nach dem Ausführen in die gleiche Richtung blicken.
Also muss er sich um `360` Grad (oder ein Vielfaches davon) drehen.

Beim Quadrat muss er sich also um $360/4=90$ Grad drehen, da ein
Quadrat vier Seiten hat.

Beim Dreieck muss er sich um $360/3=120$ Grad drehen.

Die Berechnung kann auch Yoshi ausführen.
Aber auf eine etwas komische Art.
Es gibt einen Befehl, der eine Zahl durch eine andere teilt.
Wie in der obigen Formel heißt dieser Befehl `/`.

Aber der Befehl muss ja immer als erstes Element der Liste stehen.
Um also $360/4$ zu berechnen, lautet der Befehl `(/ 360 4)`.
Diesen können wir das Quadrat-Programm einsetzen:


```lisp
(wiederhole 4
	(markiere 20)
	(drehe (/ 360 4))
)
```

### Geschachtelte Befehle

Die Befehle `wiederhole` und `drehe` gehen mit ihren Argumenten
unterschiedlich um.

Beim Befehl `drehe` (und auch bei vielen anderen Befehlen) kann man
annehmen, dass geschachtelte Befehle ausgeführt werden, *bevor* der
eigentliche Befehl ausgeführt wird.

Der Befehl `drehe` sieht also keine Division als Argument, sondern
nur das Ergebnis: die Zahl $90$.
So funktioniert es bei fast allen Befehlen, bis auf ein paar Ausnahmen.
Zu diesen *Spezial-Formen* gehört auch `wiederhole`.

`wiederhole` sieht die übergebenen Befehle und führt sie so oft aus,
wie nötig ist.

Woran kann man Befehle von Spezial-Formen unterscheiden?
Leider gibt es keine klare Regel.
Wenn ein Befehl nicht als Spezial-Form benannt wird, dann wird es sich
hoffentlich um einen normalen Befehl handeln.

### Fünfeck und Pentagramm

Wenn nun ein Fünfeck gezeichnet werden soll, müssen nur noch die beiden
`4` durch `5` ersetzt werden.
Zusätzlich wird die Länge `20` etwas reduziert.
Sonst passt das Fünfeck nicht mehr in das Feld.

Das resultierende Programm sieht so aus:

```lisp
(wiederhole 5
	(markiere 15)
	(drehe (/ 360 5))
)
```

Das Programm liefert das folgende Ergebnis:

!(yoshi-5.pdf)

Vorher habe ich geschrieben, dass sich Yoshi auch um ein Vielfaches von
$\ang{360}$ drehen kann.
Probieren wir das aus, indem sich Yoshi zweimal um $\ang{360}$ dreht.

Angenommen, wir wissen nicht, dass $2\cdot 360=720$ ist.
Dann können wir auch Yoshi wieder mit der Aufgabe betrauen.

Hier ist das neue Programm:

```lisp
(wiederhole 5
	(markiere 20)
	(drehe (/ (* 2 360) 5))
)
```

Als Ergebnis erhalten wir ein Pentagram:

!(yoshi-penta.pdf)

### Aufgabe 1: Modernes Dreieck

Wie kann das ursprüngliche Programm

```lisp
(markiere 20)
(drehe 120)
(markiere 20)
(drehe 120)
(markiere 20)
(drehe 120)
```

mit `wiederholung` und Division vereinfacht werden?

### Aufgabe 2: Innenwinkel

Der *Innenwinkel* bei einem gleichseitigen Dreieck beträgt $\ang{60}$,
nicht $\ang{120}$.
Auch das folgende Programm zeichnet ein Dreieck, dreht sich aber nur um
$\ang{60}$.

```lisp
(markiere -20)
(drehe 60)
(markiere 20)
(drehe 60)
(markiere -20)
(drehe 60)
```

1. Wie unterscheiden sich die gezeichneten Dreiecke? 
2. Welche Nachteile hat das Programm (z.B. Möglichkeiten der
   Vereinfachung, Orientierung von Yoshi am Ende)?

### Aufgabe 3: Rose

Welches Programm liefert das folgende Ergebnis?

!(yoshi-rose.pdf)

### Aufgabe 4: Kreiselei

1. Was passiert, wenn sich Yoshi im Fünfeck-Programm dreimal oder viermal
   um $\ang{360}$ dreht?
2. Gibt es ein Muster?
3. Wie sieht dieses Muster beim Dreieck und beim Quadrat aus?

### Aufgabe 5: Rechteck

Das folgende Programm zeichnet ein Rechteck:

```lisp
(markiere 20)
(drehe 90)
(markiere 10)
(drehe 90)
(markiere 20)
(drehe 90)
(markiere 10)
(drehe 90)
```

1. Wie kann es mit `wiederhole` vereinfacht werden?
2. Zeichne die Rose aus Aufgabe 3 mit einem Rechteck anstatte einem
   Quadrat.

## Sachen benennnen

Bisher können wir schon recht komplexe Grafiken mit wenigen Zeilen Code
zeichnen lassen.
Die Aufgabe 4: Rose gibt ein schönes Beispiel.

Jedoch gibt es bei unserem Polyeder Programm noch eine unschöne
Wiederholung:

```lisp
(wiederhole 5
	(markiere 15)
	(drehe (/ 360 5))
)
```

Die Zahl `5` muss an zwei Stellen eingegeben werden.
Einmal um anzugeben, wie viele Seiten der Polyeder haben soll.
Und einmal um den korrekten Winkel zu berechnen.

Wie sähe ein allgemeines Programm aus, um einen Polyeder zu zeichnen?

Das folgende Programm definiert eine Funktion `poly` und verwendet sie
danach wie die eingebauten Befehle `markiere`, `drehe` oder `+`:

```lisp
(def-fn poly (n)
	(wiederhole n
		(markiere 15)
		(drehe (/ 360 n))
	)
)
(poly 5)
```

Der Funktion wird ein Parameter `n` übergeben.
Innerhalb des Funktionsaufrufs wird `n` dann durch den konkreten Wert
`5` ersetzt, mit dem die Funktion aufgerufen wurde.

Allgemein definiert die Spezial-Form `def-fn` eine neue Funktion.
Der Name der Funktion ist das erste Argument.
Eine Liste mit Argumenten der Funktion ist das zweite Argument.
Alle weiteren Argumente werden beim Aufruf der Funktion ausgeführt.

Yoshi verwendet eine *funktionale Programmiersprache*, die an die
Programmiersprache LISP angelehnt ist.
Daher werden Funktionen in der weiteren Betrachtung einen wichtigen Teil
einnehmen.

Auch wenn LISP schon ein paar Tage auf dem Buckel hat
(die Sprache wurde bereits $1958$ spezifiziert),
sind die Prinzipien heute aktueller denn je.
Langsam fangen sie an, der objektorientierten Programmierung den Rang
abzulaufen.
Das zeigen zum Beispiel aktuelle Erweiterungen der Sprachen Java und
C++, aber auch moderne Sprachen wie Haskell, Scala oder Clojure.


